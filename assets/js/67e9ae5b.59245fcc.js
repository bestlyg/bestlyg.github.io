"use strict";(self.webpackChunk_bestlyg_site=self.webpackChunk_bestlyg_site||[]).push([[71603],{48729:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>p});const r=JSON.parse('{"id":"\u6570\u636e\u7ed3\u6784/\u6620\u5c04/\u6620\u5c04","title":"\u6620\u5c04(Map)","description":"\u4e5f\u53eb\u505a\u5b57\u5178\uff0c\u952e\u503c\u5bf9\u7684\u5339\u914d\uff0c\u4e24\u4e2a\u5143\u7d20\u7684\u96c6\u4e4b\u95f4\u5143\u7d20\u76f8\u4e92\u201c\u5bf9\u5e94\u201d\u7684\u5173\u7cfb\u3002","source":"@site/docs/\u6570\u636e\u7ed3\u6784/\u6620\u5c04/\u6620\u5c04.mdx","sourceDirName":"\u6570\u636e\u7ed3\u6784/\u6620\u5c04","slug":"/\u6570\u636e\u7ed3\u6784/\u6620\u5c04/","permalink":"/docs/\u6570\u636e\u7ed3\u6784/\u6620\u5c04/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"journal","previous":{"title":"\u5e76\u67e5\u96c6(UnionFindSet)","permalink":"/docs/\u6570\u636e\u7ed3\u6784/\u5e76\u67e5\u96c6/"},"next":{"title":"\u96c6\u5408(Set)","permalink":"/docs/\u6570\u636e\u7ed3\u6784/\u6620\u5c04/\u96c6\u5408"}}');var s=t(25105),i=t(8556);const a={},o="\u6620\u5c04(Map)",l={},p=[{value:"\u5e38\u7528\u6620\u5c04",id:"\u5e38\u7528\u6620\u5c04",level:2},{value:"\u6838\u5fc3\u4ee3\u7801",id:"\u6838\u5fc3\u4ee3\u7801",level:2},{value:"\u6838\u5fc3\u4ee3\u7801",id:"\u6838\u5fc3\u4ee3\u7801-1",level:2},{value:"\u6838\u5fc3\u4ee3\u7801",id:"\u6838\u5fc3\u4ee3\u7801-2",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"\u6620\u5c04map",children:"\u6620\u5c04(Map)"})}),"\n",(0,s.jsx)(e.p,{children:"\u4e5f\u53eb\u505a\u5b57\u5178\uff0c\u952e\u503c\u5bf9\u7684\u5339\u914d\uff0c\u4e24\u4e2a\u5143\u7d20\u7684\u96c6\u4e4b\u95f4\u5143\u7d20\u76f8\u4e92\u201c\u5bf9\u5e94\u201d\u7684\u5173\u7cfb\u3002"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Map \u7684\u6bcf\u4e00\u4e2a key \u662f\u552f\u4e00\u7684"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"\u5e38\u7528\u6620\u5c04",children:"\u5e38\u7528\u6620\u5c04"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["HashMap","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"\u5e95\u5c42\u4f7f\u7528\u54c8\u5e0c\u8868"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["ListMap","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"\u5e95\u5c42\u4f7f\u7528\u94fe\u8868"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["TreeMap","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"\u5e95\u5c42\u4f7f\u7528\u6811\u5f62\u7ed3\u6784"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"\u6838\u5fc3\u4ee3\u7801",children:"\u6838\u5fc3\u4ee3\u7801"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"export interface Map<K, V> {\n  size: number;\n  empty: boolean;\n  clear: () => void;\n  contains: (key: K) => boolean;\n  get: (key: K) => V | undefined;\n  set: (key: K, val: V) => boolean;\n  remove: (key: K) => boolean;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"\u6838\u5fc3\u4ee3\u7801-1",children:"\u6838\u5fc3\u4ee3\u7801"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"import { Map } from './map';\nconst RED = true;\nconst BLACK = false;\ntype Color = boolean;\nconst isRed = (node: TreeMapNode<any, any> | null) => node?.color === RED;\nconst isBlack = (node: TreeMapNode<any, any> | null) => node === null || node?.color === BLACK;\nconst setColor = (node: TreeMapNode<any, any> | null, color: Color) => {\n  /* istanbul ignore next */\n  if (node) node.color = color;\n};\nconst setRed = (node: TreeMapNode<any, any> | null) => setColor(node, RED);\nconst setBlack = (node: TreeMapNode<any, any> | null) => setColor(node, BLACK);\nexport class TreeMapNode<K, V> {\n  color = RED;\n  left: TreeMapNode<K, V> | null = null;\n  right: TreeMapNode<K, V> | null = null;\n  constructor(public key: K, public val: V, public parent: TreeMapNode<K, V> | null = null) {}\n}\nexport class TreeMap<K, V> implements Map<K, V> {\n  private _size = 0;\n  get size() {\n    return this._size;\n  }\n  get empty() {\n    return this._size === 0;\n  }\n  private root: TreeMapNode<K, V> | null = null;\n  constructor(private compare: (k1: K, k2: K) => number) {}\n  clear() {\n    this.root = null;\n    this._size = 0;\n  }\n  contains(key: K) {\n    return this.findNode(key) !== null;\n  }\n  get(key: K) {\n    return this.findNode(key)?.val ?? undefined;\n  }\n  set(key: K, val: V) {\n    let node = this.findNode(key);\n    if (node !== null) {\n      node.val = val;\n      return false;\n    }\n    if (this.root === null) {\n      this.root = node = new TreeMapNode<K, V>(key, val);\n    } else {\n      let parent = this.root;\n      let pos = 'left';\n      while (parent !== null) {\n        const compare = this.compare(parent.key, key);\n        if (compare > 0) {\n          if (parent.left === null) break;\n          parent = parent.left;\n        } else {\n          if (parent.right === null) {\n            pos = 'right';\n            break;\n          }\n          parent = parent.right;\n        }\n      }\n      parent[pos] = node = new TreeMapNode<K, V>(key, val, parent);\n    }\n    this._size++;\n    this.afterSet(node);\n    return true;\n  }\n  private afterSet(node: TreeMapNode<K, V>) {\n    let parent = node.parent;\n    if (parent === null) {\n      setBlack(node);\n      return;\n    }\n    if (isBlack(parent)) return;\n    const grand = parent.parent!;\n    const sibling = grand.left === parent ? grand.right! : grand.left!;\n    if (isRed(sibling)) {\n      setBlack(parent);\n      setBlack(sibling);\n      setRed(grand);\n      this.afterSet(grand);\n      return;\n    }\n    if (grand.left === parent) {\n      if (parent.right === node) {\n        this.rotateL(parent);\n        [parent, node] = [node, parent];\n      }\n      this.rotateR(grand);\n    } else {\n      if (parent.left === node) {\n        this.rotateR(parent);\n        [parent, node] = [node, parent];\n      }\n      this.rotateL(grand);\n    }\n    setBlack(parent);\n    setRed(node);\n    setRed(grand);\n  }\n  remove(key: K) {\n    let node = this.findNode(key);\n    if (node === null) return false;\n    if (node.left !== null && node.right !== null) {\n      const successor = this.successor(node);\n      [node.key, node.val, successor.key, successor.val] = [\n        successor.key,\n        successor.val,\n        node.key,\n        node.val,\n      ];\n      node = successor;\n    }\n    const parent = node.parent!;\n    this._size--;\n    if (node.left === null && node.right === null) {\n      if (this.root === node) {\n        this.clear();\n        return true;\n      }\n      const pos = parent.left === node ? 'left' : 'right';\n      parent[pos] = null;\n      this.afterRemove(node);\n      return true;\n    }\n    const childNode = node.left ?? node.right!;\n    if (parent === null) this.root = childNode;\n    else {\n      const pos = parent.left === node ? 'left' : 'right';\n      parent[pos] = childNode;\n    }\n    childNode.parent = parent;\n    this.afterRemove(childNode);\n    return true;\n  }\n  private afterRemove(node: TreeMapNode<K, V>) {\n    if (isRed(node)) {\n      setBlack(node);\n      return;\n    }\n    const parent = node.parent;\n    if (parent === null) return;\n    const leftChild = parent.left === null || parent.left === node;\n    let sibling = leftChild ? parent.right! : parent.left!;\n    if (leftChild) {\n      if (isRed(sibling)) {\n        this.rotateL(parent);\n        setBlack(sibling);\n        setRed(parent);\n        sibling = parent.right!;\n      }\n      if (isBlack(sibling.left) && isBlack(sibling.right)) {\n        const parentIsBlack = isBlack(parent);\n        setRed(sibling);\n        setBlack(parent);\n        parentIsBlack && this.afterRemove(parent);\n        return;\n      }\n      if (isBlack(sibling.right)) {\n        this.rotateR(sibling);\n        sibling = sibling.parent!;\n      }\n      this.rotateL(parent);\n      setColor(sibling, parent.color);\n      setBlack(parent);\n      setBlack(sibling.right);\n    } else {\n      if (isRed(sibling)) {\n        this.rotateR(parent);\n        setBlack(sibling);\n        setRed(parent);\n        sibling = parent.left!;\n      }\n      if (isBlack(sibling.left) && isBlack(sibling.right)) {\n        const parentIsBlack = isBlack(parent);\n        setRed(sibling);\n        setBlack(parent);\n        parentIsBlack && this.afterRemove(parent);\n        return;\n      }\n      if (isBlack(sibling.left)) {\n        this.rotateL(sibling);\n        sibling = sibling.parent!;\n      }\n      this.rotateR(parent);\n      setColor(sibling, parent.color);\n      setBlack(parent);\n      setBlack(sibling.left);\n    }\n  }\n  private successor(node: TreeMapNode<K, V>) {\n    let successor = node.right!;\n    while (successor.left) successor = successor.left;\n    return successor;\n  }\n  private findNode(key: K, root = this.root): TreeMapNode<K, V> | null {\n    if (root === null) return null;\n    const compare = this.compare(root.key, key);\n    if (compare > 0) return this.findNode(key, root.left);\n    if (compare < 0) return this.findNode(key, root.right);\n    return root;\n  }\n  private rotateL(grand: TreeMapNode<K, V>) {\n    const root = grand.parent;\n    const parent = grand.right!;\n    if (root === null) this.root = parent;\n    else {\n      const pos = root.left === grand ? 'left' : 'right';\n      root[pos] = parent;\n    }\n    grand.right = parent.left;\n    if (parent.left) parent.left.parent = grand;\n    parent.left = grand;\n    grand.parent = parent;\n    parent.parent = root;\n  }\n  private rotateR(grand: TreeMapNode<K, V>) {\n    const root = grand.parent;\n    const parent = grand.left!;\n    if (root === null) this.root = parent;\n    else {\n      const pos = root.left === grand ? 'left' : 'right';\n      root[pos] = parent;\n    }\n    grand.left = parent.right;\n    if (parent.right) parent.right.parent = grand;\n    parent.right = grand;\n    grand.parent = parent;\n    parent.parent = root;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"\u6838\u5fc3\u4ee3\u7801-2",children:"\u6838\u5fc3\u4ee3\u7801"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"import { Map } from './map';\nimport { TreeMap } from './treeMap';\n\nexport function toHash(data: any, max: number) {\n  const jsonStr = JSON.stringify(data);\n  let res = 0;\n  for (let i = 0, n = jsonStr.length; i < n; i++) {\n    res = (res + jsonStr.codePointAt(i)!) % max;\n  }\n  return res;\n}\nexport class HashMap<K, V> implements Map<K, V> {\n  private list: TreeMap<K, V>[] = [];\n  private _size = 0;\n  get size() {\n    return this._size;\n  }\n  get empty() {\n    return this._size === 0;\n  }\n  constructor(private compare: (t1: K, t2: K) => number, private max = 31) {}\n  clear() {\n    this.list.length = 0;\n    this._size = 0;\n  }\n  contains(key: K) {\n    const tree = this.list[toHash(key, this.max)];\n    if (!tree) return false;\n    return tree.contains(key);\n  }\n  get(key: K) {\n    const tree = this.list[toHash(key, this.max)];\n    if (!tree) return undefined;\n    return tree.get(key);\n  }\n  set(key: K, val: V) {\n    const idx = toHash(key, this.max);\n    let tree = this.list[idx];\n    if (!tree) this.list[idx] = tree = new TreeMap(this.compare);\n    if (tree.set(key, val)) {\n      this._size++;\n      return true;\n    } else return false;\n  }\n  remove(key: K) {\n    const tree = this.list[toHash(key, this.max)];\n    if (!tree) return false;\n    if (tree.remove(key)) {\n      this._size--;\n      return true;\n    } else return false;\n  }\n}\n"})})]})}function c(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8556:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>o});var r=t(58101);const s={},i=r.createContext(s);function a(n){const e=r.useContext(i);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);
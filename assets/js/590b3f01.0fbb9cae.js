"use strict";(self.webpackChunk_bestlyg_site=self.webpackChunk_bestlyg_site||[]).push([[68177],{66716:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"leetcode/1801-1900/\u79ef\u538b\u8ba2\u5355\u4e2d\u7684\u8ba2\u5355\u603b\u6570","title":"1801.\u79ef\u538b\u8ba2\u5355\u4e2d\u7684\u8ba2\u5355\u603b\u6570","description":"\u94fe\u63a5\uff1a1801.\u79ef\u538b\u8ba2\u5355\u4e2d\u7684\u8ba2\u5355\u603b\u6570","source":"@site/docs/leetcode/1801-1900/1801.\u79ef\u538b\u8ba2\u5355\u4e2d\u7684\u8ba2\u5355\u603b\u6570.md","sourceDirName":"leetcode/1801-1900","slug":"/leetcode/1801-1900/\u79ef\u538b\u8ba2\u5355\u4e2d\u7684\u8ba2\u5355\u603b\u6570","permalink":"/docs/leetcode/1801-1900/\u79ef\u538b\u8ba2\u5355\u4e2d\u7684\u8ba2\u5355\u603b\u6570","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1801,"frontMatter":{},"sidebar":"journal","previous":{"title":"1800.\u6700\u5927\u5347\u5e8f\u5b50\u6570\u7ec4\u548c","permalink":"/docs/leetcode/1701-1800/\u6700\u5927\u5347\u5e8f\u5b50\u6570\u7ec4\u548c"},"next":{"title":"1802.\u6709\u754c\u6570\u7ec4\u4e2d\u6307\u5b9a\u4e0b\u6807\u5904\u7684\u6700\u5927\u503c","permalink":"/docs/leetcode/1801-1900/\u6709\u754c\u6570\u7ec4\u4e2d\u6307\u5b9a\u4e0b\u6807\u5904\u7684\u6700\u5927\u503c"}}');var t=r(86070),l=r(31503);const i={},o="1801.\u79ef\u538b\u8ba2\u5355\u4e2d\u7684\u8ba2\u5355\u603b\u6570",p={},c=[{value:"\u9898\u89e3 1 - typescript",id:"\u9898\u89e3-1---typescript",level:2},{value:"\u9898\u89e3 2 - cpp",id:"\u9898\u89e3-2---cpp",level:2},{value:"\u9898\u89e3 3 - cpp",id:"\u9898\u89e3-3---cpp",level:2},{value:"\u9898\u89e3 4 - rust",id:"\u9898\u89e3-4---rust",level:2}];function u(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"1801\u79ef\u538b\u8ba2\u5355\u4e2d\u7684\u8ba2\u5355\u603b\u6570",children:"1801.\u79ef\u538b\u8ba2\u5355\u4e2d\u7684\u8ba2\u5355\u603b\u6570"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["\u94fe\u63a5\uff1a",(0,t.jsx)(n.a,{href:"https://leetcode.cn/problems/number-of-orders-in-the-backlog",children:"1801.\u79ef\u538b\u8ba2\u5355\u4e2d\u7684\u8ba2\u5355\u603b\u6570"}),(0,t.jsx)(n.br,{}),"\n","\u96be\u5ea6\uff1aMedium",(0,t.jsx)(n.br,{}),"\n","\u6807\u7b7e\uff1a\u6570\u7ec4\u3001\u6a21\u62df\u3001\u5806\uff08\u4f18\u5148\u961f\u5217\uff09",(0,t.jsx)(n.br,{}),"\n","\u7b80\u4ecb\uff1a","\u7ed9\u4f60\u4e00\u4e2a\u4e8c\u7ef4\u6574\u6570\u6570\u7ec4 orders \uff0c\u8f93\u5165\u6240\u6709\u8ba2\u5355\u540e\uff0c\u8fd4\u56de\u79ef\u538b\u8ba2\u5355\u4e2d\u7684 \u8ba2\u5355\u603b\u6570 \u3002\u7531\u4e8e\u6570\u5b57\u53ef\u80fd\u5f88\u5927\uff0c\u6240\u4ee5\u9700\u8981\u8fd4\u56de\u5bf9 109 + 7 \u53d6\u4f59\u7684\u7ed3\u679c\u3002"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"\u9898\u89e3-1---typescript",children:"\u9898\u89e3 1 - typescript"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u7f16\u8f91\u65f6\u95f4\uff1a2021-04-11"}),"\n",(0,t.jsx)(n.li,{children:"\u6267\u884c\u7528\u65f6\uff1a332ms"}),"\n",(0,t.jsx)(n.li,{children:"\u5185\u5b58\u6d88\u8017\uff1a59.5MB"}),"\n",(0,t.jsx)(n.li,{children:"\u7f16\u7a0b\u8bed\u8a00\uff1atypescript"}),"\n",(0,t.jsxs)(n.li,{children:["\u89e3\u6cd5\u4ecb\u7ecd\uff1a","\u5229\u7528\u4e70\u5927\u9876\u5806\u548c\u5356\u5c0f\u9876\u5806\u7ef4\u62a4\u6700\u503c\u3002"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class Heap<T = number> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n  *[Symbol.iterator](): IterableIterator<T> {\n    for (const t of this.arr) {\n      yield t;\n    }\n  }\n}\nfunction getNumberOfBacklogOrders(orders: number[][]): number {\n  const buyHeap = new Heap<number[]>(([t1], [t2]) => t1 - t2);\n  const sellHeap = new Heap<number[]>(([t1], [t2]) => t2 - t1);\n  const add = (order: number[]) => {\n    (order[2] === 0 ? buyHeap : sellHeap).add(order);\n    while (buyHeap.size > 0 && sellHeap.size > 0 && buyHeap.top[0] >= sellHeap.top[0]) {\n      const buyTop = buyHeap.top;\n      const sellTop = sellHeap.top;\n      if (buyTop[1] > sellTop[1]) {\n        sellHeap.remove();\n        buyTop[1] -= sellTop[1];\n      } else if (buyTop[1] < sellTop[1]) {\n        buyHeap.remove();\n        sellTop[1] -= buyTop[1];\n      } else {\n        sellHeap.remove();\n        buyHeap.remove();\n      }\n    }\n  };\n  orders.forEach(order => add(order));\n  let ans = 0;\n  for (const [, c] of buyHeap) ans += c;\n  for (const [, c] of sellHeap) ans += c;\n  return ans % (10 ** 9 + 7);\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"\u9898\u89e3-2---cpp",children:"\u9898\u89e3 2 - cpp"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u7f16\u8f91\u65f6\u95f4\uff1a2023-01-02"}),"\n",(0,t.jsx)(n.li,{children:"\u6267\u884c\u7528\u65f6\uff1a188ms"}),"\n",(0,t.jsx)(n.li,{children:"\u5185\u5b58\u6d88\u8017\uff1a57.2MB"}),"\n",(0,t.jsx)(n.li,{children:"\u7f16\u7a0b\u8bed\u8a00\uff1acpp"}),"\n",(0,t.jsxs)(n.li,{children:["\u89e3\u6cd5\u4ecb\u7ecd\uff1a","\u6a21\u62df\u3002"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"typedef pair<int, int> node;\n#define X              first\n#define Y              second\nstruct cmp {\n    int type;\n    cmp(int type): type(type) {}\n    bool operator()(node &a, node &b) {\n        if (type) return a.X < b.X;\n        else return a.X > b.X;\n    }\n};\nint mod = 1e9 + 7;\nclass Solution {\npublic:\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\n        priority_queue<node, vector<node>, cmp> buyq(cmp(1));\n        priority_queue<node, vector<node>, cmp> sellq(cmp(0));\n        for (auto &order : orders) {\n            if (order[2] == 0) {\n                node cur = make_pair(order[0], order[1]);\n                while (cur.Y && sellq.size() && sellq.top().X <= cur.X) {\n                    if (sellq.top().Y > cur.Y) {\n                        auto v = sellq.top();\n                        sellq.pop();\n                        v.Y -= cur.Y;\n                        sellq.push(v);\n                        cur.Y = 0;\n                    } else if (sellq.top().Y < cur.Y) {\n                        cur.Y -= sellq.top().Y;\n                        sellq.pop();\n                    } else {\n                        cur.Y = 0;\n                        sellq.pop();\n                    }\n                }\n                if (cur.Y) buyq.push(cur);\n            } else {\n                node cur = make_pair(order[0], order[1]);\n                while (cur.Y && buyq.size() && buyq.top().X >= cur.X) {\n                    if (buyq.top().Y > cur.Y) {\n                        auto v = buyq.top();\n                        buyq.pop();\n                        v.Y -= cur.Y;\n                        buyq.push(v);\n                        cur.Y = 0;\n                    } else if (buyq.top().Y < cur.Y) {\n                        cur.Y -= buyq.top().Y;\n                        buyq.pop();\n                    } else {\n                        cur.Y = 0;\n                        buyq.pop();\n                    }\n                }\n                if (cur.Y) sellq.push(cur);\n            }\n        }\n        int ans = 0;\n        while (buyq.size()) ans = (ans + buyq.top().Y) % mod, buyq.pop();\n        while (sellq.size()) ans = (ans + sellq.top().Y) % mod, sellq.pop();\n        return ans;\n    }\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"\u9898\u89e3-3---cpp",children:"\u9898\u89e3 3 - cpp"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u7f16\u8f91\u65f6\u95f4\uff1a2023-01-02"}),"\n",(0,t.jsx)(n.li,{children:"\u6267\u884c\u7528\u65f6\uff1a200ms"}),"\n",(0,t.jsx)(n.li,{children:"\u5185\u5b58\u6d88\u8017\uff1a57.2MB"}),"\n",(0,t.jsx)(n.li,{children:"\u7f16\u7a0b\u8bed\u8a00\uff1acpp"}),"\n",(0,t.jsxs)(n.li,{children:["\u89e3\u6cd5\u4ecb\u7ecd\uff1a","\u540c\u4e0a\u3002"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"typedef pair<int, int> node;\n#define X              first\n#define Y              second\nstruct cmp {\n    int type;\n    cmp(int type): type(type) {}\n    bool operator()(node &a, node &b) {\n        if (type) return a.X < b.X;\n        else return a.X > b.X;\n    }\n};\nint mod = 1e9 + 7;\nclass Solution {\npublic:\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\n        priority_queue<node, vector<node>, cmp> buyq(cmp(1));\n        priority_queue<node, vector<node>, cmp> sellq(cmp(0));\n        for (auto &order : orders) {\n            auto &q1 = order[2] == 0 ? sellq : buyq,\n                 &q2 = order[2] == 0 ? buyq  : sellq;\n            node cur = make_pair(order[0], order[1]);\n            while (cur.Y && q1.size() && (order[2] == 0 ? q1.top().X <= cur.X : q1.top().X >= cur.X)) {\n                if (q1.top().Y > cur.Y) {\n                    auto v = q1.top();\n                    q1.pop();\n                    v.Y -= cur.Y;\n                    q1.push(v);\n                    cur.Y = 0;\n                } else if (q1.top().Y < cur.Y) {\n                    cur.Y -= q1.top().Y;\n                    q1.pop();\n                } else {\n                    cur.Y = 0;\n                    q1.pop();\n                }\n            }\n            if (cur.Y) q2.push(cur);/\n        }\n        int ans = 0;\n        while (buyq.size()) ans = (ans + buyq.top().Y) % mod, buyq.pop();\n        while (sellq.size()) ans = (ans + sellq.top().Y) % mod, sellq.pop();\n        return ans;\n    }\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"\u9898\u89e3-4---rust",children:"\u9898\u89e3 4 - rust"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u7f16\u8f91\u65f6\u95f4\uff1a2023-01-02"}),"\n",(0,t.jsx)(n.li,{children:"\u6267\u884c\u7528\u65f6\uff1a24ms"}),"\n",(0,t.jsx)(n.li,{children:"\u5185\u5b58\u6d88\u8017\uff1a9.5MB"}),"\n",(0,t.jsx)(n.li,{children:"\u7f16\u7a0b\u8bed\u8a00\uff1arust"}),"\n",(0,t.jsxs)(n.li,{children:["\u89e3\u6cd5\u4ecb\u7ecd\uff1a","\u540c\u4e0a\u3002"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use std::{cmp::Ordering, collections::BinaryHeap};\nstruct Node(i32, i32, bool);\nimpl PartialEq for Node {\n    fn eq(&self, other: &Self) -> bool {\n        self.0 == other.0\n    }\n}\nimpl Eq for Node {}\nimpl Ord for Node {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        if self.2 {\n            self.0.cmp(&other.0)\n        } else {\n            other.0.cmp(&self.0)\n        }\n    }\n}\nimpl PartialOrd for Node {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        if self.2 {\n            self.0.partial_cmp(&other.0)\n        } else {\n            other.0.partial_cmp(&self.0)\n        }\n    }\n}\nconst mode: i32 = 1000000000 + 7;\nimpl Solution {\n    pub fn get_number_of_backlog_orders(orders: Vec<Vec<i32>>) -> i32 {\n        let mut buy_heap = BinaryHeap::<Node>::new();\n        let mut sell_heap = BinaryHeap::<Node>::new();\n        for order in orders {\n            if order[2] == 0 {\n                let mut cur = Node(order[0], order[1], order[2] == 0);\n                while cur.1 > 0 && !buy_heap.is_empty() && buy_heap.peek().unwrap().0 <= cur.0 {\n                    if buy_heap.peek().unwrap().1 > cur.1 {\n                        let mut node = buy_heap.pop().unwrap();\n                        node.1 -= cur.1;\n                        buy_heap.push(node);\n                        cur.1 = 0;\n                    } else if buy_heap.peek().unwrap().1 < cur.1 {\n                        cur.1 -= buy_heap.pop().unwrap().1;\n                    } else {\n                        cur.1 = 0;\n                        buy_heap.pop();\n                    }\n                }\n                if cur.1 > 0 {\n                    sell_heap.push(cur);\n                };\n            } else {\n                let mut cur = Node(order[0], order[1], order[2] == 0);\n                while cur.1 > 0 && !sell_heap.is_empty() && sell_heap.peek().unwrap().0 >= cur.0 {\n                    if sell_heap.peek().unwrap().1 > cur.1 {\n                        let mut node = sell_heap.pop().unwrap();\n                        node.1 -= cur.1;\n                        sell_heap.push(node);\n                        cur.1 = 0;\n                    } else if sell_heap.peek().unwrap().1 < cur.1 {\n                        cur.1 -= sell_heap.pop().unwrap().1;\n                    } else {\n                        cur.1 = 0;\n                        sell_heap.pop();\n                    }\n                }\n                if cur.1 > 0 {\n                    buy_heap.push(cur);\n                };\n            }\n        }\n        let mut ans = 0;\n        while !buy_heap.is_empty() {\n            ans = (ans + buy_heap.pop().unwrap().1) % mode;\n        }\n        while !sell_heap.is_empty() {\n            ans = (ans + sell_heap.pop().unwrap().1) % mode;\n        }\n        ans\n    }\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},31503:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var s=r(30758);const t={},l=s.createContext(t);function i(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunk_bestlyg_site=self.webpackChunk_bestlyg_site||[]).push([[51487],{41380:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>a,frontMatter:()=>r,metadata:()=>i,toc:()=>s});var d=o(86070),t=o(25710);const r={},l="729.\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868I",i={id:"leetcode/701-800/\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868I",title:"729.\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868I",description:"\u94fe\u63a5\uff1a729.\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868I",source:"@site/docs/leetcode/701-800/729.\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868I.md",sourceDirName:"leetcode/701-800",slug:"/leetcode/701-800/\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868I",permalink:"/docs/leetcode/701-800/\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868I",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:729,frontMatter:{},sidebar:"journal",previous:{title:"728.\u81ea\u9664\u6570",permalink:"/docs/leetcode/701-800/\u81ea\u9664\u6570"},next:{title:"731.\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868II",permalink:"/docs/leetcode/701-800/\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868II"}},c={},s=[{value:"\u9898\u89e3 1 - typescript",id:"\u9898\u89e3-1---typescript",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.h1,{id:"729\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868i",children:"729.\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868I"}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["\u94fe\u63a5\uff1a",(0,d.jsx)(n.a,{href:"https://leetcode.cn/problems/my-calendar-i",children:"729.\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868I"}),(0,d.jsx)(n.br,{}),"\n","\u96be\u5ea6\uff1a\u4e2d\u7b49",(0,d.jsx)(n.br,{}),"\n","\u6807\u7b7e\uff1a\u8bbe\u8ba1\u3001\u7ebf\u6bb5\u6811\u3001\u6570\u7ec4\u3001\u4e8c\u5206\u67e5\u627e\u3001\u6709\u5e8f\u96c6\u5408",(0,d.jsx)(n.br,{}),"\n","\u7b80\u4ecb\uff1a","\u5b9e\u73b0\u4e00\u4e2a MyCalendar \u7c7b\u6765\u5b58\u653e\u4f60\u7684\u65e5\u7a0b\u5b89\u6392\u3002\u5982\u679c\u8981\u6dfb\u52a0\u7684\u65e5\u7a0b\u5b89\u6392\u4e0d\u4f1a\u9020\u6210 \u91cd\u590d\u9884\u8ba2 \uff0c\u5219\u53ef\u4ee5\u5b58\u50a8\u8fd9\u4e2a\u65b0\u7684\u65e5\u7a0b\u5b89\u6392\u3002"]}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"\u9898\u89e3-1---typescript",children:"\u9898\u89e3 1 - typescript"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"\u7f16\u8f91\u65f6\u95f4\uff1a2022-07-05"}),"\n",(0,d.jsx)(n.li,{children:"\u6267\u884c\u7528\u65f6\uff1a188ms"}),"\n",(0,d.jsx)(n.li,{children:"\u5185\u5b58\u6d88\u8017\uff1a50.3MB"}),"\n",(0,d.jsx)(n.li,{children:"\u7f16\u7a0b\u8bed\u8a00\uff1atypescript"}),"\n",(0,d.jsxs)(n.li,{children:["\u89e3\u6cd5\u4ecb\u7ecd\uff1a","\u6784\u5efa rbtree\uff0c\u6bcf\u6b21\u901a\u8fc7 start\u3001end \u67e5\u627e\u4ed6\u6700\u8fd1\u7684\u503c\u7136\u540e\u8fdb\u884c\u6bd4\u8f83\u3002"]}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-typescript",children:"let NIL: RBNode<any>;\nclass RBNode<T> {\n  constructor(public key: T, public color = 0, public lchild = NIL, public rchild = NIL) {}\n  hasRedChild() {\n    return this.lchild.color === 0 || this.rchild.color === 0;\n  }\n}\nNIL = new RBNode(0, 1);\n\nclass RBTree<T extends Array<any>> {\n  root: RBNode<T> = NIL;\n  constructor(public compare: (v1: T, v2: T) => number) {}\n  print(node = this.root, init = true) {\n    if (node == NIL) return;\n    if (init) console.log('===[RBTree Print]===');\n    console.log(`${node.key}, (${node.lchild.key}, ${node.rchild.key})`);\n    this.print(node.lchild, false);\n    this.print(node.rchild, false);\n  }\n  rotateLeft(node: RBNode<T>) {\n    const newNode = node.rchild;\n    node.rchild = newNode.lchild;\n    newNode.lchild = node;\n    return newNode;\n  }\n  rotateRight(node: RBNode<T>) {\n    const newNode = node.lchild;\n    node.lchild = newNode.rchild;\n    newNode.rchild = node;\n    return newNode;\n  }\n  insert(key: T) {\n    this.root = this._insert(this.root, key);\n    this.root.color = 1;\n  }\n  _insert(node: RBNode<T>, key: T) {\n    if (node === NIL) return new RBNode(key);\n    const compare = this.compare(key, node.key);\n    if (compare === 0) {\n      node.key = key;\n      return node;\n    }\n    if (compare > 0) node.rchild = this._insert(node.rchild, key);\n    else node.lchild = this._insert(node.lchild, key);\n    return this._insertMaintain(node);\n  }\n  _insertMaintain(node: RBNode<T>) {\n    if (!node.hasRedChild()) return node;\n    if (\n      !(node.lchild.color === 0 && node.lchild.hasRedChild()) &&\n      !(node.rchild.color === 0 && node.rchild.hasRedChild())\n    )\n      return node;\n    if (node.lchild.color === 1) {\n      if (node.rchild.lchild.color === 0) node.rchild = this.rotateRight(node.rchild);\n      node = this.rotateLeft(node);\n    } else if (node.rchild.color === 1) {\n      if (node.lchild.rchild.color === 0) node.lchild = this.rotateLeft(node.lchild);\n      node = this.rotateRight(node);\n    }\n    node.color = 0;\n    node.lchild.color = node.rchild.color = 1;\n    return node;\n  }\n\n  remove(key: T) {\n    this.root = this._remove(this.root, key);\n    this.root.color = 1;\n  }\n  _remove(node: RBNode<T>, key: T) {\n    if (node == NIL) return node;\n    const compare = this.compare(key, node.key);\n    if (compare > 0) node.rchild = this._remove(node.rchild, key);\n    else if (compare < 0) node.lchild = this._remove(node.lchild, key);\n    else {\n      if (node.lchild === NIL || node.rchild === NIL) {\n        const tmp = node.lchild === NIL ? node.rchild : node.lchild;\n        tmp.color += node.color;\n        return tmp;\n      } else {\n        let tmp = node.lchild;\n        while (tmp.rchild !== NIL) tmp = tmp.rchild;\n        node.key = tmp.key;\n        node.lchild = this._remove(node.lchild, tmp.key);\n      }\n    }\n    return this._removeMaintain(node);\n  }\n  _removeMaintain(node: RBNode<T>) {\n    if (node.lchild.color !== 2 && node.rchild.color !== 2) return node;\n    if (node.hasRedChild()) {\n      let type = 0;\n      node.color = 0;\n      if (node.lchild.color === 0) node = this.rotateRight(node);\n      else (node = this.rotateLeft(node)), (type = 1);\n      node.color = 1;\n      if (type === 1) node.lchild = this._removeMaintain(node.lchild);\n      else node.rchild = this._removeMaintain(node.rchild);\n      return node;\n    }\n    if (\n      (node.lchild.color === 1 && !node.lchild.hasRedChild()) ||\n      (node.rchild.color === 1 && !node.rchild.hasRedChild())\n    ) {\n      node.color += 1;\n      node.lchild.color -= 1;\n      node.rchild.color -= 1;\n      return node;\n    }\n    if (node.lchild.color === 1) {\n      if (node.lchild.lchild.color !== 0) {\n        node.lchild.color = 0;\n        node.lchild = this.rotateLeft(node.lchild);\n        node.lchild.color = 1;\n      }\n      node.lchild.color = node.color;\n      node.rchild.color = 1;\n      node = this.rotateRight(node);\n    } else {\n      if (node.rchild.rchild.color !== 0) {\n        node.rchild.color = 0;\n        node.rchild = this.rotateRight(node.rchild);\n        node.rchild.color = 1;\n      }\n      node.rchild.color = node.color;\n      node.lchild.color = 1;\n      node = this.rotateLeft(node);\n    }\n    node.lchild.color = node.rchild.color = 1;\n    return node;\n  }\n  successor(node: RBNode<T>) {\n    let successor = NIL;\n    if (node.rchild) {\n      successor = node.rchild;\n      while (successor.lchild) successor = successor!.lchild;\n      return successor;\n    }\n    let tmp = this.root;\n    while (tmp) {\n      if (tmp.key > node.key) {\n        successor = tmp;\n        tmp = tmp.lchild;\n      } else {\n        tmp = tmp.rchild;\n      }\n    }\n    return tmp;\n  }\n  check([start, end]: T): boolean {\n    let node = this.root;\n    while (node !== NIL) {\n      if (node.key[0] >= end) node = node.lchild;\n      else if (node.key[1] <= start) node = node.rchild;\n      else break;\n    }\n    if (node === NIL) return true;\n    let tmp = node;\n    while (tmp !== NIL && tmp.key[1] >= start) {\n      const [tstart, tend] = tmp.key;\n      if (\n        (start > tstart && start < tend) ||\n        (end > tstart && end < tend) ||\n        (start <= tstart && end >= tend)\n      )\n        return false;\n      tmp = this.successor(tmp);\n    }\n    return true;\n  }\n}\nclass MyCalendar {\n  tree = new RBTree<number[]>((v1, v2) => v1[0] - v2[0]);\n  book(start: number, end: number): boolean {\n    const ans = this.tree.check([start, end]);\n    if (ans) this.tree.insert([start, end]);\n    return ans;\n  }\n}\n"})})]})}function a(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(h,{...e})}):h(e)}},25710:(e,n,o)=>{o.d(n,{R:()=>l,x:()=>i});var d=o(30758);const t={},r=d.createContext(t);function l(e){const n=d.useContext(r);return d.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),d.createElement(r.Provider,{value:n},e.children)}}}]);
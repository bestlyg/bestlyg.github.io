"use strict";(self.webpackChunk_bestlyg_site=self.webpackChunk_bestlyg_site||[]).push([[35760],{50910:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"leetcode/1601-1700/\u6700\u5c0f\u4e0d\u517c\u5bb9\u6027","title":"1681.\u6700\u5c0f\u4e0d\u517c\u5bb9\u6027","description":"\u94fe\u63a5\uff1a1681.\u6700\u5c0f\u4e0d\u517c\u5bb9\u6027","source":"@site/docs/leetcode/1601-1700/1681.\u6700\u5c0f\u4e0d\u517c\u5bb9\u6027.md","sourceDirName":"leetcode/1601-1700","slug":"/leetcode/1601-1700/\u6700\u5c0f\u4e0d\u517c\u5bb9\u6027","permalink":"/docs/leetcode/1601-1700/\u6700\u5c0f\u4e0d\u517c\u5bb9\u6027","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1681,"frontMatter":{},"sidebar":"journal","previous":{"title":"1678.\u8bbe\u8ba1Goal\u89e3\u6790\u5668","permalink":"/docs/leetcode/1601-1700/\u8bbe\u8ba1Goal\u89e3\u6790\u5668"},"next":{"title":"1684.\u7edf\u8ba1\u4e00\u81f4\u5b57\u7b26\u4e32\u7684\u6570\u76ee","permalink":"/docs/leetcode/1601-1700/\u7edf\u8ba1\u4e00\u81f4\u5b57\u7b26\u4e32\u7684\u6570\u76ee"}}');var s=t(25105),u=t(8556);const r={},o="1681.\u6700\u5c0f\u4e0d\u517c\u5bb9\u6027",c={},d=[{value:"\u9898\u89e3 1 - cpp",id:"\u9898\u89e3-1---cpp",level:2}];function l(n){const e={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,u.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"1681\u6700\u5c0f\u4e0d\u517c\u5bb9\u6027",children:"1681.\u6700\u5c0f\u4e0d\u517c\u5bb9\u6027"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["\u94fe\u63a5\uff1a",(0,s.jsx)(e.a,{href:"https://leetcode.cn/problems/minimum-incompatibility",children:"1681.\u6700\u5c0f\u4e0d\u517c\u5bb9\u6027"}),(0,s.jsx)(e.br,{}),"\n","\u96be\u5ea6\uff1aHard",(0,s.jsx)(e.br,{}),"\n","\u6807\u7b7e\uff1a\u4f4d\u8fd0\u7b97\u3001\u6570\u7ec4\u3001\u52a8\u6001\u89c4\u5212\u3001\u72b6\u6001\u538b\u7f29",(0,s.jsx)(e.br,{}),"\n","\u7b80\u4ecb\uff1a","\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\xa0nums\u200b\u200b\u200b \u548c\u4e00\u4e2a\u6574\u6570\xa0k\xa0\u3002\u4f60\u9700\u8981\u5c06\u8fd9\u4e2a\u6570\u7ec4\u5212\u5206\u5230\xa0k\xa0\u4e2a\u76f8\u540c\u5927\u5c0f\u7684\u5b50\u96c6\u4e2d\uff0c\u4f7f\u5f97\u540c\u4e00\u4e2a\u5b50\u96c6\u91cc\u9762\u6ca1\u6709\u4e24\u4e2a\u76f8\u540c\u7684\u5143\u7d20\u3002\u4e00\u4e2a\u5b50\u96c6\u7684 \u4e0d\u517c\u5bb9\u6027\xa0\u662f\u8be5\u5b50\u96c6\u91cc\u9762\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u7684\u5dee\u3002\u8bf7\u4f60\u8fd4\u56de\u5c06\u6570\u7ec4\u5206\u6210 k\xa0\u4e2a\u5b50\u96c6\u540e\uff0c\u5404\u5b50\u96c6 \u4e0d\u517c\u5bb9\u6027 \u7684 \u548c\xa0\u7684 \u6700\u5c0f\u503c\xa0\uff0c\u5982\u679c\u65e0\u6cd5\u5206\u6210\u5206\u6210 k\xa0\u4e2a\u5b50\u96c6\uff0c\u8fd4\u56de -1\xa0\u3002"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"\u9898\u89e3-1---cpp",children:"\u9898\u89e3 1 - cpp"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"\u7f16\u8f91\u65f6\u95f4\uff1a2023-06-28"}),"\n",(0,s.jsx)(e.li,{children:"\u6267\u884c\u7528\u65f6\uff1a1852ms"}),"\n",(0,s.jsx)(e.li,{children:"\u5185\u5b58\u6d88\u8017\uff1a303.8MB"}),"\n",(0,s.jsx)(e.li,{children:"\u7f16\u7a0b\u8bed\u8a00\uff1acpp"}),"\n",(0,s.jsxs)(e.li,{children:["\u89e3\u6cd5\u4ecb\u7ecd\uff1a","\u72b6\u6001\u538b\u7f29+\u8bb0\u5fc6\u5316\u641c\u7d22\u3002"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#define MAX 8\nclass Solution {\npublic:\n    int minimumIncompatibility(vector<int>& nums, int k) {\n        int n = nums.size(), m[17] = {0};\n        for (auto &num : nums) {\n            m[num]++;\n            if (m[num] > k) return -1;\n        }\n        if (k == n) return 0;\n        sort(nums.begin(), nums.end());\n        // cout << "nums : ";\n        // for (auto &num : nums) cout << num << ", ";\n        // cout << endl;\n        // int dp[k + 1][1 << n];\n        // memset(dp, 0, sizeof(dp));\n        // for (int i = 1; i <= k; i++) {\n        //     int res = 0x3f3f3f3f;\n        // }\n        // return dp[k][1 << n];\n        unordered_map<int, unordered_map<int, int>> cache;\n        function<int(int, int)> dfs = [&](int cur, int used) {\n            // cout << "==> cur = " << cur << ", used = " << bitset<MAX>(used).to_string() << endl;\n            if (cur == k) return 0;\n            if (cache[cur][used]) return cache[cur][used];\n            // cout << "in" << endl;\n            int res = 0x3f3f3f3f;\n            auto lists = comp(n / k, n, used, nums);\n            // cout << "lists = ";\n            // for (auto &list : lists) {\n            //     cout << "[";\n            //     for (auto &num : list) {\n            //         cout << num << ", ";\n            //     }\n            //     cout << "], ";\n            // }\n            // cout << endl;\n            for (auto &list : lists) {\n                int next_used = used, nmin = INT_MAX, nmax = INT_MIN;\n                for (auto &i : list) {\n                    nmin = min(nmin, nums[i]);\n                    nmax = max(nmax, nums[i]);\n                    next_used |= 1 << i;\n                }\n                auto next = dfs(cur + 1, next_used);\n                // cout << "nmin = " << nmin << ", nmax = " << nmax << endl;\n                // cout << "res = " << res << ", dfs = " << next << endl;\n                res = min(res,  next + nmax - nmin);\n            }\n            // cout << "==> cur = " << cur << ", used = " << bitset<MAX>(used).to_string() << ", res = " << res << endl;\n            return cache[cur][used] = res;\n        };\n        return dfs(0, 0);\n    }\n    vector<vector<int>> comp(int cnt, int total, int used, vector<int>& nums) {\n        // cout << "comp " << cnt << ", " << total << ", " << bitset<MAX>(used).to_string() << endl;\n        vector<vector<int>> res;\n        vector<int> list;\n        function<void(int, int)> dfs = [&](int idx, int sum) {\n            // cout << "dfs " << idx << ", " << sum << ", list = ";\n            // for (auto &item : list) cout << item << ", ";\n            // cout << endl;\n            if (total - idx < sum) return;\n            else if (sum == 0) res.push_back(list);\n            else {\n                int cur_num = nums[idx];\n                bool is_used = used & (1 << idx);\n                if (!is_used) {\n                    list.push_back(idx);\n                    int next_idx = idx + 1;\n                    while (next_idx < total && nums[next_idx] == nums[idx]) next_idx++;\n                    dfs(next_idx, sum - 1);\n                    list.pop_back();\n                }\n                int next_idx = idx + 1;\n                while (next_idx < total && nums[idx] == nums[next_idx] && !is_used) next_idx++;\n                dfs(next_idx, sum);\n            }\n        };\n        dfs(0, cnt);\n        return res;\n    }\n};\n'})})]})}function m(n={}){const{wrapper:e}={...(0,u.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(l,{...n})}):l(n)}},8556:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>o});var i=t(58101);const s={},u=i.createContext(s);function r(n){const e=i.useContext(u);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),i.createElement(u.Provider,{value:e},n.children)}}}]);